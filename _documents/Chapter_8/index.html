
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>第八章：实施密码技术 &#8212; 《Security+ 学习手册》 alpha 文档</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="../Chapter_9/index.html" />
    <link rel="prev" title="第七章：管理身份识别和访问" href="../Chapter_7/index.html" />
<link rel="stylesheet" type="text/css" href="../../_static/handsontable.full.min.css">
<script src="../../_static/handsontable.full.min.js"></script>

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>第八章：实施密码技术<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<ul>
<li><p>课程简介</p>
<blockquote>
<div><p>到现在为止，你学习和使用的大部分安全机制都依赖于密码学原理。事实上，密码学时信息安全领域最重要的理念之一。加密和解密服务可以防止未经授权的实体读取数据——但加密技术的作用远不止于此，甚至可以在组织内形成整个基础架构。在本章课程中，你将深入讨论密码学的理论概念，并实施可为安全性奠定基础的实用解决方案。</p>
</div></blockquote>
</li>
<li><p>课程目标</p>
<blockquote>
<div><p>在本章课程中，你将：</p>
<ul class="simple">
<li><p>确定高级密码学概念</p></li>
<li><p>选择合适的加密算法</p></li>
<li><p>配置一个PKI</p></li>
<li><p>注册数字证书</p></li>
<li><p>备份并恢复数字证书和私钥</p></li>
<li><p>销毁数字证书</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="section" id="a">
<h2>课题A：确定高级密码学概念<a class="headerlink" href="#a" title="永久链接至标题">¶</a></h2>
<p>确定课程的开始部分会向你展示主要密码学概念的概述。在本章课程中，你将学习密码学背后的一些更复杂的理念。</p>
<div class="section" id="id2">
<h3>密码学元素<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>密码学的学科包含几个子概念。下表描述了这些子概念。</p>
<table class="colwidths-given docutils align-default" id="id43">
<caption><span class="caption-text">密码学</span><a class="headerlink" href="#id43" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>密码学元素</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>混淆（Confiusion）</p></td>
<td><p>使加密密钥和密文之间的关系变得尽可能复杂和隐蔽的技术。混淆可以防止攻击者选择性地生成明文消息的加密版本并寻找它们关系中的某些模式。</p></td>
</tr>
<tr class="row-odd"><td><p>扩散（Diffusion）</p></td>
<td><p>即使在明文输入中发生轻微变化也能使密文发生剧烈变化的一种技术。扩散能防止攻击者选择性地确定由相同密钥加密地部分消息。</p></td>
</tr>
<tr class="row-even"><td><p>冲突（Collision）</p></td>
<td><p>两个不同的明文输入产生完全相同的密文输出。如果加密算法易受冲突影响，其完整性就会减弱，并且攻击者可以用另一个能产生相同密文的消息替换这个消息。</p></td>
</tr>
<tr class="row-odd"><td><p>模糊（Obfuscation）</p></td>
<td><p>正如你所见，模糊处理使得源代码变得更加难以阅读。因此，模糊处理与加密类似。但是，模糊处理中不涉及密钥的使用——任何知道模糊算法的人都能将代码转换回可读模式。因此模糊代码的安全性比加密数据更低。</p></td>
</tr>
<tr class="row-even"><td><p>伪随机生成数（PRNG）</p></td>
<td><p>这是一种由算法产生的随机数的过程，伪随机数是指有着近似随机性的数字，但不是真正的随机。伪随机数是基于初始种子状态生成的，这是定义数字生成第一阶段的一个数字。然后种子状态通过一个数学公式输出伪随机数。加密密钥的生成倾向于使用伪随机数。</p></td>
</tr>
<tr class="row-odd"><td><p>完全正向保密[Perfect forward secrecy（PFS）]</p></td>
<td><p>当某个会话期间使用的一个密钥收到损害时，这种会话加密特性能确保之前由该密钥加密的数据不会受到影响。如果攻击者恰好窃取到私钥，PFS可以防止攻击者破坏以往的会话。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id3">
<h3>散列概念<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>正如您所知，散列一个明文输入会产生一个固定长度的密文输出，被称为消息摘要，反之则不然。但是，如果攻击者再彩虹表中计算大量消息摘要，则明文输入可能时可预测的。密码盐（cryptofraphic salt）通过为每个明文输入添加一个随机值来缓解彩虹表攻击的影响。它能对摘要造成重大改变。同样，如果盐本身发生变化，那么使用不同盐的相同明文属兔将生成两个独特的摘要。</p>
<p>盐值通常与散列数据存储再一起，因此盐本身不会被隐藏。但即使攻击者知道特定会话的盐值，它们也需要结合这个盐值来计算新的唯一彩虹表，这是不可行的。在任何包含密码散列的安全系统中，为散列添加盐值都是必须的。</p>
<p>与密码盐有关的时一个临时数（nonce）。术语“临时数”是指仅使用一次的数字。盐可以在会话之间改变，但也可以保持不变——正如其名称所暗示的，临时数永远不会重复。鉴于盐通常用于散列密码的情况下，认证协议中更常使用临时数来防止重放攻击。</p>
<div class="section" id="id4">
<h4>初始化向量<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h4>
<p>盐与临时数都可以被认为是初始化向量（IV），这是一种通用术语，描述了用于初始化加密任务的任何值，以确保每个输出都是唯一的。虽然IV通常用于双向加密方法而非单向散列的环境下，但这些术语经常被混合使用。</p>
</div>
</div>
<div class="section" id="id5">
<h3>数据状态<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>有三种主要的数据状态，每种状态都有各自的密码相关性。</p>
<p>静止数据（Data at rest）主要是指被存储在各种介质上的任何数据，不会从一种介质移动到另一种介质。可能静止的数据类型的示例包含存储在数据库中的财务信息，归档视听媒体，操作策略和其他管理文档、系统配置数据等等。根据其敏感程度的级别，静止数据可以由管理数据的软件或存储数据的硬件进行加密。在发生违规事件是，加密的静止数据通过防止攻击者向公众或其他未授权方传播私人数据支持了数据的机密性。</p>
<p>传输中的数据（Data in transit）主要是指在媒介之间移动的任何数据，例如通过专用网络和互联网传输。可能正在传输的数据类型的示例包括网站流量、远程访问流量、云存储库之间的数据同步等等。在数据可以被认为是静止之前，它通常会在计算机之间传输。加密这些数据能防止中间人攻击者危及传输通道和流经它的任何数据。</p>
<p>正在使用的数据（Data in use）是指当前正在被创建、删除、读取或写入的任何数据。可能正在使用的数据类型的示例包括在文字处理应用程序中打开的文档，当前正在被修改的数据库数据，操作系统运行时生成的事件日志等等。当用户使用数据时，这些数据通常需要先进行解密，因为它从静止状态变为使用状态。数据在整个工作会话中可能会保持未加密状态，使其处于危险之中。但是，有些机制能够加密存储在内存中的数据，使第三方无法解码信息。</p>
</div>
<div class="section" id="id6">
<h3>密钥交换<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>密钥交换（Key exchange）是指加密密钥在实体之间传输时使用的任何方法，以便能够使用加密算法。</p>
<p>为了使发送者和接收者能交换加密消息，每一方都必须准备好加密被发送的消息并解密被接收的消息。他们需要准备的内容取决于所使用的加密技术。如果他们使用代码（code），则两者都需要相同的代码薄副本。如果他们使用密码（cipher），他们将需要适当的密钥：</p>
<ul class="simple">
<li><p>如果密码使对称密钥密码，则两者都需要相同密钥副本。</p></li>
<li><p>如果密码使具有公钥/私钥属性的非对称密钥密码，则任何需要加密消息的实体都需要收件人的公钥。</p></li>
</ul>
<p>密钥交换有两种基本类型：带内（in-band）和带外（out-of-band）。带内密钥交换使用与共享数据相同的路径，而带外交换则使用不同的路径，例如电话呼叫或实际会议。对称密钥加密需要带外密钥交换以避免密钥被拦截。</p>
</div>
<div class="section" id="id7">
<h3>数字证书<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>数字证书（digital signature）是以用户私钥加密的消息摘要。非对称加密算法可以与散列算法一起使用来创建数字签名。发送方创建消息文本的散列版本，然后使用发送方私钥加密散列本身。加密的散列作为数字签名附加到消息上。</p>
<p>发送方向接收方提供签名消息和相应的公钥。接收方使用公钥来解密签名以显示发送方的散列版本。这种方式可以证明发送方的身份，因为如果公钥和私钥不匹配，接收方就将无法解密签名。然后接收方用公钥创建文档的新散列版本并比较两个散列值。如果它们匹配，就证明数据没有被修改。因此数字签名能同时支持身份验证和完整性。由于特定的加密散列值对发送方来说是唯一的，因此数字签名也支持不可否认行。</p>
<div class="section" id="id8">
<h4>散列的加密<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>重要的是要记住，数字签名是一种散列，随后才是被加密的概念。如果没有加密，对方就能轻易地：</p>
<ol class="arabic simple">
<li><p>拦截文件和散列值</p></li>
<li><p>修改文件</p></li>
<li><p>重新创建散列</p></li>
<li><p>将修改后地文件和散列发送给接收方</p></li>
</ol>
</div>
</div>
<div class="section" id="id9">
<h3>密码套件<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>密码套件（cipher suite）是用于在主机之间建立安全连接的对称和非对称加密算法集合。通常与安全套接字层（SSL）/传输层安全性（TLS）网络协议有关，已有200多种已知密码套件可用，每种都提供不同级别的保护。使用弱密码的密码套件应当避免；这种套件对于现代使用而言密钥长度通常太短（例如40位或56位）。具有强密码的密码套件使用128位和/或256位密码长度，并且算法本身中没有已知的重大漏洞。</p>
<p>密码套件定义了密钥交换算法，批量加密算法、消息认证码算法和伪随机函数。</p>
<table class="colwidths-given docutils align-default" id="id44">
<caption><span class="caption-text">密码套件</span><a class="headerlink" href="#id44" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>密码套件的组成</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>密钥交换算法</p></td>
<td><p>确定客户端和服务器在SSL/TLS连接握手过程中是否以及如何进行身份认证。</p></td>
</tr>
<tr class="row-odd"><td><p>Bulk加密算法</p></td>
<td><p>加密实际的消息流，并包含密钥大小。</p></td>
</tr>
<tr class="row-even"><td><p>消息认证码算法</p></td>
<td><p>创建消息摘要</p></td>
</tr>
<tr class="row-odd"><td><p>伪随机函数</p></td>
<td><p>创建主密钥，主密钥是指在两个保持连接的系统之间共享的48节密钥。</p></td>
</tr>
</tbody>
</table>
<div class="section" id="tls-1-3">
<h4>TLS 1.3中的密码套件更改<a class="headerlink" href="#tls-1-3" title="永久链接至标题">¶</a></h4>
<p>截至2017年8月，TLS 1.3仍处于工作草案阶段。TLS的这个草案版本以不同方案定义了密码套件，它们只包含了对称密码和消息认证代码。因此TLS 1.3密码套件与先前的密码套件不兼容。</p>
</div>
</div>
<div class="section" id="id10">
<h3>会话密钥<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>会话密钥（session key）是一次性使用的对称密钥，用于加密单个相关通讯系列中的所有消息。使用会话密钥有两个主要原因：</p>
<ul class="simple">
<li><p>随着越来也多使用特定密钥加密的素材变得可用，使得一些密码分析攻击变得更容易或更成功。通过将密钥的使用限制在唯一的通信会话中，就能限制用该密钥加密的数据量。</p></li>
<li><p>使用会话密钥比单独使用非对称加密更快，更高效。你仍可以使用非对称算法加密另一个更快对称算法的对称密钥。这确保了密钥被安全地进行分配，并且还能提高整体性能。还有时被称为混合密码术。</p></li>
</ul>
</div>
<div class="section" id="id11">
<h3>密钥延展<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>密码延展（Key streching）是一种可能可以加强弱密码密钥（如人们创建的密码或通行码）的技术，防止暴力破解。在密码延展中，原始密码通过在密码延展算法中运行来得到增强。增强型密钥通常大于128位，这使得它们难以通过暴力攻击被破解。</p>
<p>密码延展技术包括：</p>
<ul class="simple">
<li><p>重复循环加密散列函数</p></li>
<li><p>重复循环块密码</p></li>
<li><p>密钥用于密码的情况下，配置密码的密钥的调度以增加密钥设置所需的时间。</p></li>
</ul>
</div>
<div class="section" id="id12">
<h3>密码学方面的特殊考虑<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>除了迄今为止所研究的密码学概念和技术之外，还有一些你需要考虑的密码学特性。这些特性仅适用于一些常见用例，不适用于其他情况。</p>
<table class="colwidths-given docutils align-default" id="id45">
<caption><span class="caption-text">密码学方面</span><a class="headerlink" href="#id45" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>考虑</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>低延迟</p></td>
<td><p>在许多业务场景中，处理数据时花费的每一秒都不能忽略。加密操作最终可能在某种状态下的数据上花费了相当的处理时间。因此，密码算法的一个目标是实现低延迟，这里的延迟一般被定义为将输入添加到用于处理的算法中与获得输出之间的时间。</p></td>
</tr>
<tr class="row-odd"><td><p>低功耗设备</p></td>
<td><p>低延迟算法或轻量算法的一种特定应用是针对那些耗能非常少且处理能力最低的设备。例如，物联网（IoT）和智能设备在可用资源方面的一定的限制。同时，有必要在这些资源与设备的安全要求之间取得平衡。因此，轻量级算法旨在提供足够的安全性，同时消耗最少的资源。</p></td>
</tr>
<tr class="row-even"><td><p>泄露回弹</p></td>
<td><p>加密算法和技术可能会容易受到旁路攻击（side-channel attack）的影响，这种攻击方式会收集加密实施过程中的物理信息，如系统消耗了多少能源，在执行加密技术时处理器处于何种状态等。此类消息可以帮助执行特殊的分析，使攻击者得以破解加密实施。为了防御这种攻击，一些算法针对信息泄露提供了高度的恢复能力。泄露回弹技术致力于消除全部与部分泄露来源；或者致力于切断被泄露信息与保密材料之间的联系。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="b">
<h2>课题B：选择加密算法<a class="headerlink" href="#b" title="永久链接至标题">¶</a></h2>
<p>你已经确定了密码学的许多概念，现在可以开始将这些概念应用于现实世界的一些特定算法。</p>
<div class="section" id="id13">
<h3>密码的类型<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>加密密码有两种主要的类型：流密码和块密码。</p>
<table class="colwidths-given docutils align-default" id="id46">
<caption><span class="caption-text">密码的类型</span><a class="headerlink" href="#id46" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>密码类型</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>流密码（Stream cipher）</p></td>
<td><p>一种一次加密一个位元的数据加密类型。每个明文位元被转换成加密密文。这些密码的执行速度相对较快，并且不需要太多的性能开销。密文的大小于原文相同。这种方法比其他方法产生的错误更少，并且发生错误时，它们只会影响一个位元。</p></td>
</tr>
<tr class="row-odd"><td><p>块密码（Block cipher）</p></td>
<td><p>这种密码一次性加密一个数据块，通常以64位的数据块形式进行加密。这种密码通常更强大，更安全，但它的性能也比流加密更低。块密码通过多种可能运行模式中的一种来实现，这些模式定义了块密码将如何重复地将数据转换为多个块。</p></td>
</tr>
</tbody>
</table>
<div class="section" id="id14">
<h4>运算模式<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<p>常见地运行模式包括：</p>
<ul class="simple">
<li><p>电子代码薄[Electronic Code Book（ECB）]，其中每个明文块都是用相同地密钥加密。</p></li>
<li><p>密码块链接[Cipher Block Chaining（CBC）]，其中使用初始向量（IV）加密第一个明文块，然后，对于每个后续操作，明文块和前一个密文块通过异或（XOR）进行运算。</p></li>
<li><p>密码反馈[Cipher Feedback（CFB）]，其中先对IV进行加密，然后用它地结果与前一个明文块进行异或运算。</p></li>
<li><p>输出反馈[Output Feedback（OFB）]，其中加密IV的结果会被反馈到后续运算中。</p></li>
<li><p>计数器[Counter（CTR）]或计数器模式[Counter Mode（CTM）]，其中使用数字计数器的值创建不断变化的IV。</p></li>
<li><p>填充/明文密码块链接[Propagating/Plaintext Cipher Block Chaining（PCBC）]，其中每个明文块都与前面的明文块和密文块进行异或运算。</p></li>
<li><p>伽罗瓦/计数器模式[Galois/Counter Mode（GCM）]，在密码模式的标准加密服务中加入了认证功能。</p></li>
</ul>
</div>
</div>
<div class="section" id="id15">
<h3>散列算法的类型<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>以下是用于散列加密的一些常用算法。</p>
<table class="colwidths-given docutils align-default" id="id47">
<caption><span class="caption-text">散列算法的类型</span><a class="headerlink" href="#id47" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>散列算法</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>消息摘要5（MD5）</p></td>
<td><p>该算法产生一个128位的消息摘要。它由Ronald Rivest创建，现在处于公有领域。MD5已经不再被认为是一种强大的散列函数，因此应当避免使用；但是，它在一些有限的情况下仍然有用，例如计算机取证。</p></td>
</tr>
<tr class="row-odd"><td><p>安全散列算法</p></td>
<td><p>这种算法在MD5之后进行建模，被认为是两者中较强的一个。SHA的常用版本包括产生160位散列值的SHA-1，而SHA-256，SHA-384和SHA-512分别产生256位、384位和512位的摘要。SHA-1因其对冲突攻击的弱点而被弃用。</p></td>
</tr>
<tr class="row-even"><td><p>RACE原始完整性校验消息摘要（RIPEMD）</p></td>
<td><p>RIPEMD是基于现在已经过时MD4算法中使用的设计原则进行设计的。128位、160位、256位和320位版本分别被称为RIPEMD-128、RIPEMD-160、RIPEMD-256和RIPEMD-320。256位和320位版本降低了产生重复输出散列的概率，但在高级安全性方面表现不佳。IPEMD-160由开放学术社区设计，并且它的使用频率低于SHA-1。</p></td>
</tr>
<tr class="row-odd"><td><p>基于散列的消息认证码（HMAC）</p></td>
<td><p>这是一种通常将密码散列函数（例如MD5或SHA-256）与密钥组合在一起来验证消息完整性和真实性的方法。最终的计算是基于使用底层散列函数来进行命名的。例如，如果SHA-256是散列函数，那么HMAC算法就被命名位HMAC-SHA256。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id16">
<h3>对称加密算法的类型<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<p>以下是用于对称加密的一些常用算法，也称为密钥算法。</p>
<table class="colwidths-given docutils align-default" id="id48">
<caption><span class="caption-text">对称加密算法的类型</span><a class="headerlink" href="#id48" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>对称算法</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>数据加密标准（DES）</p></td>
<td><p>一种块密码对称加密算法，它使用一个56位的密钥对64位的数据块进行加密，其中，密钥中有8位奇偶校验。短密钥长度使DES成为一种相对较弱的算法，尽管它需要较少的性能开销。</p></td>
</tr>
<tr class="row-odd"><td><p>三次DES（3DES）</p></td>
<td><p>这总对称加密算法对每个数据块进行三次处理，每次使用不同的密钥，以此进行数据的加密。它首先使用一个密钥将明文加密成密文，然后再用另一个密钥加密该密文，最后用第三种密钥加密第二次形成的密文。3DES比DES更强大，但也将性能影响提高了三倍。</p></td>
</tr>
<tr class="row-even"><td><p>高级加密标准（AES）</p></td>
<td><p>由比利时密码学家Joan Daemen和Vincent Rijmen开发的对称128位、192位或256位块密码，被美国政府采纳作为加密标准以取代DES。这种AES算法以其创建者的名字被命令位Rijndael（发音为“Rhine-dale”）。Rijndael是NIST举办的AES竞赛中被认为可采纳的五种算法之一。AES被认为是目前最强大的加密算法之一，其性能优于3DES。</p></td>
</tr>
<tr class="row-odd"><td><p>Blowfish</p></td>
<td><p>一种免费可用的64位块密码算法，使用可变的密钥长度。它由Bruce Schneier开发。Blowfish已经不再被认为是强大的，虽然它提供比DES更好的性能。</p></td>
</tr>
<tr class="row-even"><td><p>Twofish</p></td>
<td><p>一种对称密钥块密码，与Blowfish类似，包含一个128位的块和256位的密钥。虽然未被选作一种标准，但它在AES竞赛中挺进了前五。Twofish加密使用一个预计算的加密算法。这个加密算法是一个依赖密钥的S盒（S-box），当给定密钥时，这个相对较为复杂的密钥算法就会在其位置上提供一个置换密钥。被称为“n”，有128，192和256位大小。“n”的一半由加密密钥组成，另一半包含了在加密算法中使用的一个修饰符。Twoflish比Blowfish更加强大，并且提供了相对较高的性能。</p></td>
</tr>
<tr class="row-odd"><td><p>Rivest Cipher（RC）</p></td>
<td><p>由Ronald Rivest开发的一系列算法。所有算法都有着可变的密钥长度。RC4是一种流密码。RC5和RC6是大小可变的块密码。RC6被认为是一种强大的密码，并提供良好的性能。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id17">
<h3>非对称加密算法的类型<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>以下是用于非对称加密的一些常用算法和技术。</p>
<table class="colwidths-given docutils align-default" id="id49">
<caption><span class="caption-text">非对称加密算法的类型</span><a class="headerlink" href="#id49" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>非对称技术</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Rivest Shamir Adelman（RSA）</p></td>
<td><p>以它的设计者Ronald Rivest，Adi Shamir和Len Adelman命名，RSA是第一个用于公钥加密的成功算法。它有一个可变的密钥长度和块大小。这种算法仍在广泛使用中，并且如果它使用了足够长的密钥，就能被认为具有高度安全。</p></td>
</tr>
<tr class="row-odd"><td><p>Diffie-Hellman（DH）</p></td>
<td><p>提供安全密钥交换的密码技术。在1976年的描述中，它奠定了大多数公钥加密实现的基础，包括RSA、DHE和ECDHE。DH交换中使用的密钥强度由组决定。组的数量越高，密钥的安全性越高，并且添加到计算中的处理开销也越多。</p></td>
</tr>
<tr class="row-even"><td><p>Diffie-Hellman 临时（DHE）</p></td>
<td><p>DH的一种变形，使用临时密钥来提供安全的密钥交换。</p></td>
</tr>
<tr class="row-odd"><td><p>椭圆曲线加密（ECC）</p></td>
<td><p>一种利用有限域上椭圆曲线的代数结构的公钥加密技术。ECC通常与无线和移动设备一起使用。</p></td>
</tr>
<tr class="row-even"><td><p>数字签名算法（DSA）</p></td>
<td><p>用于数字签名的公钥加密标准，为消息提供了身份验证和完整性验证。</p></td>
</tr>
<tr class="row-odd"><td><p>良好隐私（PGP）和GNU隐私卫士（GPG）</p></td>
<td><p>PGP是专有的电子邮件安全和身份验证软件，使用公钥加密技术的一种变形来对电子邮件进行加密。GPG和PGP的开源版本，提供了等效加密和认证服务。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id18">
<h3>密钥延展算法的类型<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>一种流行的密钥延展方法就是使用密钥衍生函数：</p>
<ul>
<li><p>基于密码的密钥衍生函数2[Password-Based Key Derivation Function 2(PBKDF2)]是来自RSA实验室的公开密钥密码标准中的一部分。这个密钥衍生函数使用五个输入参数来创建衍生密钥：</p>
<blockquote>
<div><ul class="simple">
<li><p>伪随机函数，例如散列、密码或HMAC</p></li>
<li><p>用于生成衍生密钥的主密码</p></li>
<li><p>密码盐值</p></li>
<li><p>进行循环的函数的指定迭代次数</p></li>
<li><p>衍生循环的函数的指定迭代次数</p></li>
</ul>
</div></blockquote>
</li>
<li><p>bcrypt是基于Blowfish密码的密钥衍生函数。想PBKDF2一样，它使用密码盐，但也会通过增加迭代次数随时间的推移而进行调节。有针对Ruby、Python、C、C#、Perl、PHP、Java和其他语言的bcypt实现。</p></li>
</ul>
</div>
<div class="section" id="id19">
<h3>替换密码<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>用于支持混淆的最基本技术之一是替换密码（substitution cipher）。在替换密码中，每个明文单位在转换为密文时保持相同的顺序，但单元的实际值发生了变化。为了解除密文的混淆，则只要应用反向替代。</p>
<p>例如，ROT13就是一个简单的替换密码，用字母表上位于该字母后面的第13个字母替换它。换句话说，字母”A”变成字母“N”。例如，词语”substitution cipher”变成“fhofgvghgvba pvcure”。这种替代密码提供了一种非常基本的混淆形式，且相比严肃的技术更像时一种教学工具。与此同时，替代概念还被用于某些安全环境中（例如，S盒的替换密钥）。</p>
</div>
<div class="section" id="id20">
<h3>异或<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<p>用于混淆的另一种技术时异或[exclusive or(XOR)]运算。从最基本的意义上看，只有当一个输入为真，另一个输入为假时，XOR运算才会输出为真。该运算本身被称为“XORing”，在运算计算时称两个输入为“取其中不相同的部分（XORed）”。XORing是逐位进行的，这意味着该操作对每一位都有效。例如，大写字母“E”的二进制值是01000101，小写字母“s”的二进制值是01110011。0代表加，而1代表真。</p>
<p>正如你从该示例所看到的，异或运算的结果是00110110，在ASCⅡ中对应的字符是6。在密码学领域，异或运算通常用于混淆恶意代码。</p>
<p>由于异或运算快速，简单只需要很少的处理开销，因此它们常常被有着丰富知识的恶意软件作者用来隐藏他们的恶意软件以便被检测到。代码通过混淆器运行，混淆器会对代码进行异或运算，使代码的基本分析变得困难。</p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>XOR还在AES等块密码中起到支持作用。</p>
</div>
<div class="section" id="id21">
<h4>隐匿式安全<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h4>
<p>混淆和隐匿式安全（security through obscurity）理念密切相关，这是一种试图向他人掩盖脆弱存在的做法。虽然隐匿式安全可以有效地为你的安全操作添砖加瓦，但不应仅仅依靠它来实现安全性。大多数情况下，攻击者是否会发现你试图隐藏的漏洞并不是一个问题，问题是何时发现的。</p>
</div>
</div>
<div class="section" id="id22">
<h3>加密模块<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<p>加密模块（cryptogtaphic module）是指实现一个或多个加密概念的任何软硬件解决方案，如前面提到的不同加解密算法。一旦你选择了一个足够强大的算法在你的环境中使用，就需要通过一些方法将该算法应用到需要保护的资产中；加密模块促进了实施过程。</p>
<p>一种模块类型是加密服务提供程序[Cryptographic Service Provider(CSP)]，这是实现Microsoft CryptoAPI的Windows软件库。Microsoft为软件开发人员提供了其中几种CSP。开发人员可以设计他们的应用程序来调用CSP，使之可以为应用程序执行一个或多个加密服务。例如，应用程序可以使用Microsoft增强型密码提供程序来生成具有可定义盐长度的128位RC4密钥。除了加密算法本身之外，每个CSP还指定其他加密项目，如密钥长度，使用的密钥交换算法，使用的数字签名算法、数字签名的格式等。</p>
</div>
</div>
<div class="section" id="c">
<h2>课题C：配置公钥基础架构<a class="headerlink" href="#c" title="永久链接至标题">¶</a></h2>
<p>在双方之间交换密钥传输的过程建立在提供加密服务套件的互联服务器的明确接收上。从公司私有网络内的加密通讯到全球互联网的加密通讯，都包含在公共密钥基础设施中。</p>
<div class="section" id="id23">
<h3>公钥基础架构<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<p>公钥基础架构[public key infrastructure（PKI）]是一个由证书颁发机构、证书、软件、服务和其他密码组件组成的系统，用于实现数据和实体的真实性和有效性。PKI可以以各种分层结构实施，可以面向公众开放也可以由组织进行私有维护。顾名思义，PKI实施了非对称加密过程，实现了网络数据的加解密，包括通过互联网进行的交易。</p>
</div>
<div class="section" id="pki">
<h3>PKI组件<a class="headerlink" href="#pki" title="永久链接至标题">¶</a></h3>
<p>PKI中包含了许多密码组件。下表列出了这些组件中最重要的一些。</p>
<table class="colwidths-given docutils align-default" id="id50">
<caption><span class="caption-text">PKI组件</span><a class="headerlink" href="#id50" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>PKI组件</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>数字证书（digtial certificate）</p></td>
<td><p>数字证书是PKI最基本的组成部分，PKI的首要任务是以各种方式管理数字证书。数字证书是一种将证书与公钥关联起来的电子文档。用户和设备都可以持有证书。证书通过数字签名验证证书持有者的身份，证书也是分发持有者公钥的一种方式。此外，证书还包含与持有人身份有关的信息。</p></td>
</tr>
<tr class="row-odd"><td><p>对象识别符[Object identifier（OID）]</p></td>
<td><p>包含在证书中的身份信息是通过OID提供的。由许多OID与常用证书类型相关联，每种OID都定义了证书所有者身份的某个维度。OID被格式化位一系列由句点分割的数字；例如，OID 2.5.4.10 表示了拥有证书的组织的名称，在证书上也简称位“Organization”或“O”</p></td>
</tr>
<tr class="row-even"><td><p>证书颁发机构[certificate authority（CA）]</p></td>
<td><p>CA是指发布数字证书并维护关联私钥/公钥对的服务器。</p></td>
</tr>
<tr class="row-odd"><td><p>注册机构[registration authority（RA）]</p></td>
<td><p>RA服务器负责验证用户和设备的身份以及批准或拒绝数字证书的请求。</p></td>
</tr>
<tr class="row-even"><td><p>数字签名请求[Certificate signing request（CRS）]</p></td>
<td><p>CSR是指发送到CA的消息，其中的资源会申请证书。通常包含被纳入到资源证书中的信息，如公钥、数字签名和其他识别信息。</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>一些大型的CA可能还有本地的注册机构（LRA）。</p>
</div>
</div>
<div class="section" id="ca">
<h3>CA层次结构<a class="headerlink" href="#ca" title="永久链接至标题">¶</a></h3>
<p>CA层次结构（CA hierarchy）或信任模型（trust model）是指一个或一组共同协作用于发布数字证书的CA。层次结构中的每个CA与它正上方的CA具有父子关系。CA层次结构提供了一种在多个CA之间分配证书工作的方式，并提高了证书服务供应的效率。如果一个CA受损，只有由这个特定CA发布的证书及其子证书无效。层次结构中的其余CA仍将保持有效。</p>
<p>当用户，设备或其他实体获得证书时，会通过信任链（chain of trust）（也称为证书链）验证此证书。信任链从底部开始并沿着CA层次结构向上进行。直接呈现给实体的证书可能由另一个CA签署，而这个CA又是由其上方的CA依次签署，依此类推。如果要信任某个证书，实体就必须信任链中的每一个链，因为它们的工作方式正是如此。</p>
<div class="section" id="id24">
<h4>证书锁定<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h4>
<p>相比典型CA层次结构，证书锁定（Certificate pinning）是一种更直接的信任证书的方式。以下面的步骤为例：</p>
<ol class="arabic simple">
<li><p>你的浏览器信任位于CA层次结构顶部的根CA</p></li>
<li><p>你导航至 develetech.com，该网站会显示其证书。</p></li>
<li><p>develetech.com 证书由 DevetechCA 签署，这个证书经过了多个中间CA的签署，最终通向根CA。</p></li>
</ol>
<p>因此，在普通CA信任方案中，你的浏览器将信任 develetech.com。但在证书锁定中：</p>
<ol class="arabic simple">
<li><p>你的浏览器直接信任 develetech.com 证书，或直接信任 DevtehCA。</p></li>
<li><p>当 develetech.com 展示其证书时，你的浏览器信任该站点，甚至不验证根CA。</p></li>
</ol>
<p>证书锁定有效地绕过了CA层次结构和信任链，以便能最大限度地减少中间人攻击。如果其中地一个中间CA受到了危害，则CA层次结构中地信任关系也会受到影响。但是，由于被锁定地证书不依赖于这个完整的信任链，因此，客户端和锁定证书之间的信任关系保持不变。</p>
</div>
</div>
<div class="section" id="id25">
<h3>根CA<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<p>根CA（root CA）是层次结构中最高的CA，因此也是最可信的权威机构。根CA发布并自签署链中的第一个证书。根CA必须是安全的，因为如果它受到损害，所有其他证书都将失效。</p>
<div class="section" id="id26">
<h4>公有根和私有根<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h4>
<p>根CA可以被指定为公有或私有：</p>
<ul class="simple">
<li><p>私有根CA（private root CA）由公司创建，主要在公司内部使用。这种根CA可以由内部进行设置和配置，也可以外包给第三方供应商。</p></li>
<li><p>公有根CA（public root CA）由第三方或商业供应商创建，供公众进行一般访问。</p></li>
</ul>
<p>赛门铁克、Comodo、GoDaddy和IdenTrust都是公共证书服务和知名供应商。</p>
</div>
</div>
<div class="section" id="id27">
<h3>从属CA<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>从属CA（Subordinate CA）是指层次结构中根目录下的任何CA。从属CA颁发证书并提供证书的日常管理、包括续订、暂停和撤销。</p>
</div>
<div class="section" id="id28">
<h3>离线根CA<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h3>
<p>为了为根CA提供尽可能最安全的环境，组织通常会设置根CA并使其离线，从而允许从属CA颁发所有其余的证书。从这种意义上看，使根CA离线意味着将其于网络断开连接，并（可选的）将其置于断电状态。这种策略确保网络中的任何人都无法访问根CA，因此受攻击的可能性大大降低。需要记住的是如果根CA收到危害，则层次结构中的所有证书都会受到影响。因此，使根CA保持联机状态时非常危险的和不明智的。</p>
</div>
<div class="section" id="id29">
<h3>证书的类型<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<p>证书可以颁发给许多不同类型的实体，也可以为组织中各种不同目的而颁发证书。</p>
<table class="colwidths-given docutils align-default" id="id51">
<caption><span class="caption-text">证书的类型</span><a class="headerlink" href="#id51" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>证书类型</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>自签名（Self-signed）</p></td>
<td><p>自签名证书是指由签署给证书的同一个实体拥有的证书。换句话说，这种证书不承认信任链上的任何更高层权威机构——实体本质上是在证明自己。自签名证书要求客户端直接信任实体。</p></td>
</tr>
<tr class="row-odd"><td><p>根</p></td>
<td><p>根证书由根CA颁发，证明信任链中其下所有其他证书的有效性。由于链中没有比根证书更高的权威机构，所以它必须是自签名的。</p></td>
</tr>
<tr class="row-even"><td><p>用户</p></td>
<td><p>在不鼓励记住和管理密码的情况下，会向用户颁发用户证书。例如，在SSH的许多实现中，当用户想在系统上打开一个远程shell时，就会向SSH服务器出示他们自己的证书。</p></td>
</tr>
<tr class="row-odd"><td><p>计算机</p></td>
<td><p>也可以向IAM系统中具有个人或组身份的计算机颁发证书。如果计算机需要安全地连接到网络中地另一台服务器，就可能需要使用证书来进行身份验证，而不是使用更人性化的密码。</p></td>
</tr>
<tr class="row-even"><td><p>电子邮件</p></td>
<td><p>这种证书用于对安全/多用途Internet邮件扩展（S/MIME）协议中的电子邮件消息进行认证和加密。S/MIME的用途与PGP类似，但需要依赖PKI的集中管理。</p></td>
</tr>
<tr class="row-odd"><td><p>代码签名</p></td>
<td><p>在开发者将应用程序发布给他们之前，他们通常会对源代码进行数据签名，以便客户可以验证该应用是否合法。在许多情况下，代码时使用开发人员自签名证书部署的，但开发人员也可以利用CA颁发证书。</p></td>
</tr>
<tr class="row-even"><td><p>主体备用名称[Subject Alternative Name（SAN）]</p></td>
<td><p>在某些情况下，拥有多个域的组织可能想要将这些域组合到一个SSL/TLS证书中。SAN是X.509证书标准的一种扩展，为组织提供了配置证书范围以涵盖多个域的能力。例如，develetech.com和develetech.org可以都使用相同的证书。</p></td>
</tr>
<tr class="row-odd"><td><p>通配符（Wildcard）</p></td>
<td><p>通配符证书域SAN证书相似，但并非实现了多个域的同时使用，而是使证书可以使用域多个子域。例如，通配符证书不仅可以验证develetech.com，还能验证products.develetech.com、sales.develetech.com和news.develetech.com。这种证书应该被格式化为 <a href="#id30"><span class="problematic" id="id31">*</span></a>.develetech.com 以包含任何可能的子域。</p></td>
</tr>
<tr class="row-even"><td><p>域验证[Domain validation（DV）]</p></td>
<td><p>域验证证书表明某些实体可以通过不同的方法来控制特定域名，例如，向域的Whois记录中的联系人发送电子邮件并等待响应。这些证书提供的验证相对较弱，因为实际上他们无法证明这个域是由声称拥有该域控制权的实体合法拥有。</p></td>
</tr>
<tr class="row-odd"><td><p>扩展验证[Extended validation(EV)]</p></td>
<td><p>为了应对域验证证书的弱点，扩展验证证书提供了一种强大得多的证据，即一个合法实体拥有特定域的所有权。对大多数公共CA而言，颁发EV需要执行彻底的检查以验证实体，例如通过公共目录中列出的电话号码验证联系人，并要求通过验证的联系人有一位为其提供担保的监督人员。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="x-509">
<h3>X.509<a class="headerlink" href="#x-509" title="永久链接至标题">¶</a></h3>
<p>PKI和CA层次结构遵循一种用于格式化证书的标准，称为X.509，X.509使用CSR中提供的信息定义了证书的结构。除公钥之外，X.509证书通常还包含以下信息：</p>
<ul class="simple">
<li><p>X.509版本</p></li>
<li><p>证书的序列号</p></li>
<li><p>用于签署证书的算法</p></li>
<li><p>发行实体的名称</p></li>
<li><p>证书有效的时间段</p></li>
<li><p>由证书验证的主体的名称</p></li>
<li><p>可选属性，如组织名称、组织单位、地区、城市、州、联系电子邮件地址等。</p></li>
</ul>
</div>
<div class="section" id="id32">
<h3>证书文件格式<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<p>X.509证书可以以几种不同的文件格式存在，每种格式都以不同方式配置X.509信息。</p>
<table class="colwidths-given docutils align-default" id="id52">
<caption><span class="caption-text">证书文件格式</span><a class="headerlink" href="#id52" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>X.509文件格式</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>.der</p></td>
<td><p>这种格式以二进制可辨别编码规则（DER）格式对证书进行编码。</p></td>
</tr>
<tr class="row-odd"><td><p>.pem</p></td>
<td><p>隐私增强型电子邮件（PEM）格式使用Base64（用文本形式编码二进制数据的方法）编码DER证书。使用这种格式的文件始终以“—–BEGIN CERTIFICATE—–”行开始，并以“—–END CERTIFICATE—–”行结束。</p></td>
</tr>
<tr class="row-even"><td><p>.cer</p></td>
<td><p>这种格式以二进制DER格式编码证书，但在Windows系统中可能包含以PEM编码的数据。类Unix系统上的等效格式使用.crt扩展名。</p></td>
</tr>
<tr class="row-odd"><td><p>.p7b</p></td>
<td><p>这种格式使用公钥加密标准#7(PKCS#7)以Base64格式编码证书数据。PKSC#7编码证书不能包含私钥数据。</p></td>
</tr>
<tr class="row-even"><td><p>.p12</p></td>
<td><p>这种格式书用公钥加密标准#12（PKCS#12）以Base64格式编码证书数据。PKCS#12编码的证书可以包含私钥数据并且可能受密码保护。</p></td>
</tr>
<tr class="row-odd"><td><p>.pfx</p></td>
<td><p>这种格式由Microsoft开发，使PKCS#12的前身。这两种格式经常互换使用。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id33">
<h3>CA层次结构的设计选项<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h3>
<p>你的CA层次结构的设计将取决于组织的业务和安全要求。下表介绍了如何在不同公司配置中部署CA层次结构。</p>
<table class="colwidths-given docutils align-default" id="id53">
<caption><span class="caption-text">CA层次结构的设计选项</span><a class="headerlink" href="#id53" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>公司配置</p></th>
<th class="head"><p>CA层次结构的实施</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>几十名本地员工</p></td>
<td><p>使用没有从属的单个根CA，这个CA为办公地点上的所有员工提供服务。</p></td>
</tr>
<tr class="row-odd"><td><p>分布全世界的数千名员工</p></td>
<td><p>从属CA根据地理位置进行指定，以平衡各个CA中颁发的证书数量。</p></td>
</tr>
<tr class="row-even"><td><p>只需要访问特定应用程序的个人</p></td>
<td><p>从属CA根据功能或由部门指定，使独立CA能为具有特定资源需求的人群提供服务。</p></td>
</tr>
<tr class="row-odd"><td><p>严格的安全性允许个人对同一资源拥有不同的访问级别</p></td>
<td><p>从属CA根据获得证书所需的安全性进行指定。有些CA可能会被设置为颁发使用网络ID和密码的证书；其他一些CA可能会要求个人出示有效的驾驶执照。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="d">
<h2>课题D：注册证书<a class="headerlink" href="#d" title="永久链接至标题">¶</a></h2>
<p>使用证书的过程包含了几个阶段。第一阶段是为需要证书的实体（如用户、设备和服务）注册和安装证书。在本章课题中，你将为需要他们的各种实体注册证书。</p>
<div class="section" id="id34">
<h3>证书注册过程<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h3>
<p>用户和其他实体通过证书注册过程从CA中获取证书。</p>
<p>下表介绍了每个注册步骤。</p>
<table class="colwidths-given docutils align-default" id="id54">
<caption><span class="caption-text">注册步骤</span><a class="headerlink" href="#id54" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>注册步骤</p></th>
<th class="head"><p>说明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ol class="arabic simple">
<li><p>实体请求证书</p></li>
</ol>
</td>
<td><p>实体按照程序（例如，填写在线表单）获得证书。</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="2">
<li><p>RA认证实体</p></li>
</ol>
</td>
<td><p>认证根据证书策略的要求（例如，网络用户ID和密码，驾驶执照或其他唯一标识符）进行确定。</p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="3">
<li><p>将策略应用到请求中</p></li>
</ol>
</td>
<td><p>RA应用与颁发证书的特定CA相关的证书策略。</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="4">
<li><p>请求被发送给CA</p></li>
</ol>
</td>
<td><p>如果实体的身份成功通过认证并满足策略要求，则RA将证书请求发送到CA。</p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="5">
<li><p>CA颁发证书</p></li>
</ol>
</td>
<td><p>CA创建证书并将其放入存储库。</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="6">
<li><p>通知实体</p></li>
</ol>
</td>
<td><p>CA通知实体证书可用并交付证书。</p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="7">
<li><p>证书安装</p></li>
</ol>
</td>
<td><p>获得证书后，可以使用合适的工具进行安装。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id35">
<h3>证书生命周期<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h3>
<p>证书生命周期中有几个主要阶段。</p>
<table class="colwidths-given docutils align-default" id="id55">
<caption><span class="caption-text">生命周期的每个阶段</span><a class="headerlink" href="#id55" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>证书生命周期的阶段</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ol class="arabic simple">
<li><p>颁发</p></li>
</ol>
</td>
<td><p>生命周期从根CA发布其自签名密钥对开始。然后根CA开始向其他CA和最终用户颁发证书。</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="2">
<li><p>注册</p></li>
</ol>
</td>
<td><p>用户和其他实体通过证书注册过程从CA获取证书。</p></td>
</tr>
<tr class="row-even"><td><p>3a. 续订</p></td>
<td><p>根据证书策略参数，证书可以多次续订。</p></td>
</tr>
<tr class="row-odd"><td><p>3b. 撤销</p></td>
<td><p>证书可再其到期日期之前撤销，从而使其永久失效。证书可能会因为各种原因被撤销，包括误用、遗失或损坏。</p></td>
</tr>
<tr class="row-even"><td><p>3c. 到期</p></td>
<td><p>证书在一定的时间长度后会到期，这种特征被建立在证书策略中并在颁发CA的过程中进行配置。到期参数是证书数据的一部分。如果根CA的证书过期，那么整个CA链就会变得无效。</p></td>
</tr>
<tr class="row-odd"><td><p>3d. 暂停</p></td>
<td><p>除永久性撤销外，一些CA还支持证书的临时暂停。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id36">
<h3>证书生命周期的管理<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h3>
<p>从一般规律上看，生命周期越长，涉及的管理开销越小。然而这也可能会带来更高的安全风险，因为更长的生命周期也会给攻击者更多的时间来破坏密钥对的密码或以其他方式危害系统。而且，随着生命周期的缩短，密码学领域中的新发展使你能够为你的实体颁发和续签更安全的证书。证书的实际生命周期取决于业务要求和安全需求。</p>
<div class="section" id="id37">
<h4>证书生命周期的因素<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h4>
<p>下表显示了影响证书生命周期的最常见因素，虽然该列表并未进行详尽的列举。</p>
<table class="colwidths-given docutils align-default" id="id56">
<caption><span class="caption-text">证书生命周期的因素</span><a class="headerlink" href="#id56" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 29%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>因素</p></th>
<th class="head"><p>变量</p></th>
<th class="head"><p>意义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>私钥长度</p></td>
<td><p>什么样的密钥长度比较合适？128位，256位，1024位，2048位等？</p></td>
<td><p>密钥越长，需要处理的数据位越多。长密钥需要更多的资源（更多的中央处理单元[CPU]周期或内存，更多的计算机，更多的时间等等）才能被破解。攻击者可能会认为这不值得一试。</p></td>
</tr>
<tr class="row-odd"><td><p>使用的密码技术的强度</p></td>
<td><p>算法有多复杂？</p></td>
<td><p>算法中使用的数学函数越复杂，攻击者解密的难度就越大。但这意味着生成密钥所需的时间也会更长。</p></td>
</tr>
<tr class="row-even"><td><p>CA和私钥的物理安全性</p></td>
<td><p>CA保存在哪里？它在一个锁定区域内还是仅由密码保护？谁有权限访问它？</p></td>
<td><p>更高的物理安全性在较长的生命周期中至关重要。如果CA及其私钥在物理上的安全性得不到保障，那么世界上所有的虚拟控制方法都无法保护它们。需要记住的是物理安全的实现成本可能很高昂。</p></td>
</tr>
<tr class="row-odd"><td><p>已颁发的证书及其私钥的安全性</p></td>
<td><p>私钥被存储在什么地方？在智能卡上？在桌面上？是否需要密码？</p></td>
<td><p>用户私钥越安全，它们对整体系统的安全性就越好。相反，用户可能会忘记密码或丢失智能卡，这意味着管理员工作的增加。</p></td>
</tr>
<tr class="row-even"><td><p>攻击风险</p></td>
<td><p>你的CA是脱机还是联机？你的根CA是在公司内部还是由第三方公司处理？你处理的是什么类型的业务？</p></td>
<td><p>你的CA可能是安全的，但攻击者可能会使用你网络上的另一个不那么安全的访问点获得CA的访问权限。</p></td>
</tr>
<tr class="row-odd"><td><p>用户信任</p></td>
<td><p>谁正在使用已颁发的证书？外部用户还是内部用户？</p></td>
<td><p>相比外部用户（通过互联网进行访问的个人），你一般可以信任内部用户（企业网络中的员工）。</p></td>
</tr>
<tr class="row-even"><td><p>管理参与</p></td>
<td><p>长生命周期需要较少的管理工作。短生命周期需要更多的管理工作。</p></td>
<td><p>虽然长生命周期需要较少的管理工作（续订、撤销等），但也给了攻击者更多时间来获得访问权限。这使得管理员跟踪证书问题成为一项重要任务。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="ssl-tls">
<h3>SSL/TLS连接过程<a class="headerlink" href="#ssl-tls" title="永久链接至标题">¶</a></h3>
<p>你可以使用证书来实现SSL/TLS连接。这个过程中有几个步骤。</p>
<table class="colwidths-given docutils align-default" id="id57">
<caption><span class="caption-text">SSL/TLS连接过程</span><a class="headerlink" href="#id57" title="永久链接至表格">¶</a></caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>SSL/TLS连接步骤</p></th>
<th class="head"><p>说明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ol class="arabic simple">
<li><p>请求</p></li>
</ol>
</td>
<td><p>客户端请求于服务器的会话</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="2">
<li><p>响应</p></li>
</ol>
</td>
<td><p>服务器通过向客户端发送数字证书和公钥进行响应</p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="3">
<li><p>协商</p></li>
</ol>
</td>
<td><p>然后服务器和客户端协议一个加密级别。</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="4">
<li><p>加密</p></li>
</ol>
</td>
<td><p>一旦在加密级别上达成一致，客户端就会生成一个会话密钥，使用服务器的公钥对其进行加密，并将它发送给服务器。</p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="5">
<li><p>通讯</p></li>
</ol>
</td>
<td><p>随后会话密钥就成为了通讯过程中用于加解密的密钥。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="e">
<h2>课题E：备份和恢复证书和私钥<a class="headerlink" href="#e" title="永久链接至标题">¶</a></h2>
<p>在之前，你已经在CA基础架构中位需要证书的实体进行了注册。但是，证书及其相关私钥可能会丢失或被破坏，因此你需要通过一些方法来恢复它们。在本章课题中，你将备份证书和密钥，以便在丢失或受到威胁时恢复它们。</p>
<div class="section" id="id38">
<h3>私钥保护方式<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h3>
<p>私钥对于CA层次结构的安全性至关重要，并且加以保护，以防止丢失、被盗或破坏。
为了保护私钥，需要：</p>
<ul class="simple">
<li><p>将私钥备份到可移动媒体并安全地保存该媒体。</p></li>
<li><p>从不安全地媒体中删除私钥。</p></li>
<li><p>恢复私钥时需要使用密码。</p></li>
<li><p>永远不要共享密钥。</p></li>
<li><p>密码发布后，切勿通过网络或互联网传输密钥。</p></li>
<li><p>考虑使用密钥托管将私钥存储到受信任地第三方。</p></li>
</ul>
</div>
<div class="section" id="id39">
<h3>密钥托管<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h3>
<p>作为密钥备份的替代方案，密钥托管（Key escrow）可以被用来安全地存储私钥，同时允许一个或多个受信任地第三方预定义条件下访问密钥。这个第三方被称为密钥托管代理（key escrow agent）。例如，在某些情况下，政府机构可能会要求私钥被放置在代理机构中进行托管。商业CA还可以为不想备份和管理自己的私钥的组织提供基于合同的托管服务。</p>
</div>
<div class="section" id="m-of-n">
<h3>M of N 控制<a class="headerlink" href="#m-of-n" title="永久链接至标题">¶</a></h3>
<p>在密钥托管方案中，只有特定数量的代理或受托人有权恢复密钥。为了防止单个授权代理恢复密钥，通常使用M of N方案（M of N scheme）。M of N方案是一种数学控制，考虑了密钥恢复代理的总数（N）以及执行密钥恢复所需的代理数量（M）。如果尝试恢复密钥的代理数量不满足或超过M，那么密钥将不会被恢复。M和N的确切值在不同的实施方案中各不相同。</p>
</div>
<div class="section" id="id40">
<h3>私钥恢复方式<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h3>
<p>如果私钥丢失或损坏，你就必须从备份或托管中恢复密钥，然后才能恢复任何加密数据。</p>
<ul class="simple">
<li><p>如果你使用密钥托管，这个密钥就会被分割给多个托管代理。代理可以使用这些部分来重建丢失的密钥或直接解密信息。</p></li>
<li><p>如果密钥已备份到可移动介质，就可以从备份位置进行恢复。</p></li>
</ul>
</div>
<div class="section" id="efs">
<h3>EFS恢复代理<a class="headerlink" href="#efs" title="永久链接至标题">¶</a></h3>
<p>加密文件系统[Encrypting File System（EFS）]使用Microsoft Windows基于NTFS的公钥加密。Windows Server 2016会根据用户证书自动创建加密证书和公钥；或者，你可以使用Windows Server 2016的Active Directory证书服务（AD CS）发布证书和密钥。</p>
<p>加密中可能会遇到一个问题是如何在加密文件的用户账户不存在的情况下恢复加密文件。例如，如果用户离开组织后删除这位用户的账户，就可能会出现此问题。Windows server 2016使你能够定义一个EFS恢复代理（recovery agent）。恢复代理是指有着能恢复被其他用户加密的文件所需证书的个人。默认情况下，Windows Server 2016将域管理员定义为EFS恢复代理。</p>
<div class="section" id="id41">
<h4>密钥存档和恢复<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h4>
<p>你还可以使用AD CS在受保护的CA数据库中的归档私钥，从而使私钥得以恢复。密钥恢复不会恢复加密的数据或消息，但它确实能帮助用户或管理员恢复密钥并在这之后用它来恢复数据（或解密数据）。</p>
</div>
</div>
<div class="section" id="id42">
<h3>私钥替换<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h3>
<p>如果私钥丢失，你可能会像在恢复任何加密数据后将密钥全部都替换掉：</p>
<ol class="arabic simple">
<li><p>首先，恢复私钥。</p></li>
<li><p>解密任何被加密的数据。</p></li>
<li><p>销毁原始密钥。</p></li>
<li><p>获取一个新的密钥对。</p></li>
<li><p>最后，使用新的私钥重新加密数据。</p></li>
</ol>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logosecurityplus.svg" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">《Security+ 学习手册》</a></h1>








<h3>导航</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Chapter_1/index.html">第一章： 确定安全基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter_2/index.html">第二章：分析风险</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter_3/index.html">第三章：确定安全威胁</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter_4/index.html">第四章：执行安全评估</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter_5/index.html">第五章：实现主机和软件的安全性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter_6/index.html">第六章：实现网络的安全性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Chapter_7/index.html">第七章：管理身份识别和访问</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">第八章：实施密码技术</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a">课题A：确定高级密码学概念</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">密码学元素</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">散列概念</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">数据状态</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">密钥交换</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">数字证书</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">密码套件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">会话密钥</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">密钥延展</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">密码学方面的特殊考虑</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#b">课题B：选择加密算法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">密码的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">散列算法的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">对称加密算法的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">非对称加密算法的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">密钥延展算法的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">替换密码</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">异或</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">加密模块</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#c">课题C：配置公钥基础架构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id23">公钥基础架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pki">PKI组件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ca">CA层次结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id25">根CA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id27">从属CA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id28">离线根CA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id29">证书的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#x-509">X.509</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id32">证书文件格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id33">CA层次结构的设计选项</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#d">课题D：注册证书</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id34">证书注册过程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id35">证书生命周期</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id36">证书生命周期的管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ssl-tls">SSL/TLS连接过程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#e">课题E：备份和恢复证书和私钥</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id38">私钥保护方式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id39">密钥托管</a></li>
<li class="toctree-l3"><a class="reference internal" href="#m-of-n">M of N 控制</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id40">私钥恢复方式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#efs">EFS恢复代理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">私钥替换</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../Chapter_7/index.html" title="上一章">第七章：管理身份识别和访问</a></li>
      <li>Next: <a href="../Chapter_9/index.html" title="下一章">&lt;no title&gt;</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, renkeju.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>